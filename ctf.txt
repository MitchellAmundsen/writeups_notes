-crypto
	-caesar
	-rot13 - similar to caesar except using key 13
	-rot47
		-hard to recognize
		-detection
			-characters adcii in range 0x21 - 0x7f
			-lots of non-alphabetical characters
			-characters are all printable
	-substitution
		-detection
			-mostly alphabets
			-normally long ciphertext
		-solution
			-frequency analysis 
			-pattern recognition (quipquip)
	-vigenere
		-key: aplhabetical string of arbitrary length
		-first letter of key with first letter of plaintext
		-key repeats
	-playfair ciphet (not so common)
		-key: table of 5X5 alphabet or a keyword
		-useful site: rumkin
	-one-time pad
		-key: string of bytes same length as plaintext
		-encryption: XOR the key with message byte by byte
		-don't use it because if you transfer the key in a secure channel, we might as well transfer the plaintext in the same channel (same length)
	-multi-time pad
	-repeated key XOR
		-key: string of bytes of any length smaller than message size
		-encryption: repeat the key multiple times until it reaches the size of the message then XOR the key with the message byte by byte
		-detection: pattern repitition (if padded with null bytes or plaintext also has some kind of repition)
		-first compute hamming distance of different key length and choose minimum one and can solve with key length)
	-symmetric
		-encryption and decryption use the same key
		-stream cipher
			-symmetric key cipher where plaintext digits are combined with pseudorandom cipher digit stream
			-common stream ciphers
				-all ones covered previously
				-RC4 (really broken)
				-Salsa20
		-block cipher
			-common block ciphers
				-DES (broken, key space too small)
				-3DES(somewhat safe)
				-AES(safe)
				-blowfish(safe)
			-what is it
				-plain text is seperated into blocks of n-bits size
				-each block is encrypted with the specific algorithm
				-join the encyrpted blocks together to form ciphertext
			-padding used before encryption to make sure plaintext is multiple of block size
-encoding
	-base64: only contains 
		- A-z
		- 0-9
		- =\+
		- usually ends with one or more ==
	-base16(hex)
		- a-f
		- 0-9
		- sometimes starts with 0x
	-octal
		-only contains 0-7
		-starts with either o or 0
	-binary
		-only contains 0,1
		-sometimes starts with 0b
	-morse
		-only contains .,_
		-sometimes represented with 0 or 1

-mess with red team?
	-spotlight to the face
		-leave thousands of ports open
		-tar pit
			-syn/ack
				-client sends syn packet
				-server sends syn/ack packet back
				-server forgets about client
				-client sends ack packet to get into port
			-windows size 0
				-complete syn/ack sucessfully
				-sends window size 0
				-client must wait to get in
		-RNG packet dropping
			-nmap thinks it's slowing connection and slows down
			-constantly slows connection of nmap user
			-never finished nmap scan
		-setup open ports with games
			-detects attacking users
			-wastes time
	-breaking stuff
		-diable PHP (see if scoring system still works, dynamic/static)
		-chroot jail
		-linux capabilities

-cross site request forgery (CSRF): attack forces an authenticated user to excute action
	-how
		-session cookie given for authentication
		-get/post request used for executing actions
		-image tag or any tag fetching source goes to given url
		-can put get request in source url of tag
		-if user is authenticated via cookies, then get request is validated
	-wrong way to fix
		-create an anti-csrf cookie with a random value
		-multi-step action
		-check the referer header
			-referer header shows where request comes from
			-checking referer header may cause problems to user
	-right way to fix
		-anti-csrf token
			-every state changing request should have one
			-sumbitted as hidden html form field
			-unique per user and session
			-large and random
		-asp.net viewstate
			-indicated the status of the current page
			-include the viewstateuserkey to make guessing nearly impossible
		-double submit cookies
			-sends random value as a cookie and request parameter
			-site checks to make sure both match
		-encrypted token
			-create encrypted token of user secret
			-ajax requests include the token as a header value
			-decrypt the token for each request and check the value
			-token van be sumbitted in a hidden-form field for non-ajax requests
		-challenge and response
			-CAPTCHA
			-one time token
		-have no XSS in you application

-deja vu 
	-client side verification is exploitable
	-always verify even if you think you have
	





